/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RpgManager
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/data/RpgFunctions.ts
var import_obsidian = require("obsidian");
var RpgFunctions = class extends import_obsidian.Component {
  constructor(app) {
    super();
    this.app = app;
    this.initialiseRoots();
  }
  static create(app) {
    return new RpgFunctions(app);
  }
  initialiseRoots() {
    const filePath = this.app.vault.getFiles()[0].path;
    let slashCount = 0;
    let p = filePath.indexOf("/");
    while (p !== -1) {
      slashCount++;
      p = filePath.indexOf("/", p + 1);
    }
    slashCount++;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      this.root = this.app.vault.getResourcePath(file);
    }
    if (this.root === null) {
      console.log("Rpg Manager failed to find the root folder!");
      return;
    }
    if (this.root.includes("?")) {
      this.root = this.root.substring(0, this.root.lastIndexOf("?"));
    }
    for (let removedSlash = slashCount; removedSlash > 0; removedSlash--) {
      this.root = this.root.slice(0, this.root.lastIndexOf("/"));
    }
    if (!this.root.endsWith("/")) {
      this.root += "/";
    }
    this.attachmentRoot = this.root + this.app.vault.config.attachmentFolderPath + "/";
  }
  fileExists(path) {
    const abstractFile = this.app.vault.getAbstractFileByPath(path);
    let response = false;
    if (abstractFile instanceof import_obsidian.TAbstractFile) {
      response = abstractFile ? true : false;
    }
    return response;
  }
  getImageLink(page) {
    const imageExtensions = ["jpeg", "jpg", "png", "webp"];
    for (let extensionCount = 0; extensionCount < imageExtensions.length; extensionCount++) {
      const fileName = this.app.vault.config.attachmentFolderPath + "/" + (page == null ? void 0 : page.file.name) + "." + imageExtensions[extensionCount];
      if (this.fileExists(fileName)) {
        return this.root + fileName;
      }
    }
    return null;
  }
  getImage(page, width = 75, height = 75) {
    let imageFile = null;
    if (page !== void 0) {
      imageFile = this.getImageLink(page);
    }
    let minimalDimensions = false;
    let dimensions = "width: " + width + "px; height: " + height + "px;";
    if (width !== 75 && height === 75) {
      dimensions = "width: " + width + "px;";
    } else if (width === 75 && height !== 75) {
      dimensions = "height: " + height + "px;";
    } else if (width === 75 && height === 75) {
      minimalDimensions = true;
    }
    if (imageFile === null) {
      if (!minimalDimensions) {
        return "";
      } else {
        return '<div style="' + dimensions + '"></div>';
      }
    }
    return '<img src="' + imageFile + '" style="object-fit: cover;' + dimensions + '">';
  }
  formatDate(date, type = null) {
    if (!date || date === void 0)
      return "";
    let options = null;
    if (type === "long") {
      options = {
        day: "numeric",
        month: "long",
        year: "numeric"
      };
      return date.toLocaleString(options);
    }
    if (type === "short") {
      options = {
        weekday: "short",
        month: "short",
        day: "numeric",
        year: "numeric"
      };
    }
    if (options !== null) {
      return date.toLocaleString(options);
    } else {
      return date.toISODate();
    }
  }
  formatTime(date) {
    if (!date || date === void 0)
      return "";
    const options = {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit"
    };
    return date.toLocaleString(options);
  }
  calculateDuration(start, end) {
    if (!start || !end)
      return "";
    const dtStart = new Date(start);
    const dtEnd = new Date(end);
    var difference = dtEnd.valueOf() - dtStart.valueOf();
    const diff = end - start;
    const minutes = difference / 6e4;
    const remaining = difference - minutes * 6e4;
    const seconds = remaining > 0 ? remaining / 1e3 : 0;
    return minutes + ":" + (seconds < 10 ? "0" + seconds : seconds);
  }
  getDeathStatus(page) {
    return page.dates.death !== null ? "<br/>_(Deceased " + this.formatDate(page.dates.death) + ")_ " : "";
  }
  calculateAge(page, campaign) {
    if (page === void 0)
      return "";
    if (!(page == null ? void 0 : page.dates.dob))
      return "";
    const end = page.dates.death || campaign.dates.current;
    const startDate = new Date(page.dates.dob);
    const endDate = new Date(end);
    const ageDifMs = endDate.valueOf() - startDate.valueOf();
    const ageDate = new Date(ageDifMs);
    return Math.abs(ageDate.getUTCFullYear() - 1970);
  }
};

// src/abstracts/AbstractModel.ts
var import_obsidian2 = require("obsidian");

// src/data/RpgMetadataValidator.ts
var RpgMetadataValidator = class {
  static validate(type, frontmatter) {
    return true;
    if (frontmatter === void 0 || Object.keys(frontmatter).length === 0) {
      return false;
    }
    return true;
  }
};

// src/factories/RpgComponentFactory.ts
var RpgComponentFactory = class {
  constructor(functions, dv) {
    this.functions = functions;
    this.dv = dv;
    this.currentPage = this.dv.current();
  }
  spacer() {
    this.dv.span('<div style="height: 20px"></div>');
  }
  adventureList() {
    this.dv.span("## Adventures");
    this.dv.table(["&#35;", "Adventure", "Synopsis"], this.dv.pages("#adventure").sort((page) => -page.ids.adventure).where((page) => page.file.folder !== "Templates" && page.ids !== null && page.ids.adventure !== null).map((page) => [
      page.ids.adventure,
      page.file.link,
      page.synopsis
    ]));
    this.spacer();
  }
  sessionList(adventureNumber = null) {
    this.dv.span("## Sessions");
    this.dv.table(["&#35;", "Session", "Type", "Synopsis", "Date", "Play Date", "Notes"], this.dv.pages("#session").sort((page) => -page.ids.session).where((page) => page.file.folder !== "Templates" && page.ids !== null && page.ids.session !== null && (adventureNumber !== null ? page.ids.adventure === adventureNumber : true)).map((page) => [
      page.ids.session,
      page.file.link,
      page.ids.type,
      page.synopsis,
      page.dates.session ? this.functions.formatDate(page.dates.session, "short") : "",
      page.dates.irl ? this.functions.formatDate(page.dates.irl) : "",
      "[[Notes - " + page.file.name + "|>>]]"
    ]));
    this.spacer();
  }
  sceneList(sessionNumber) {
    this.dv.span("## Scenes");
    this.dv.table(["&#35;", "Scene", "Start", "Duration"], this.dv.pages("#scene").sort((page) => page.ids.scene).where((page) => page.file.folder !== "Templates" && page.ids !== void 0 && page.ids.session !== void 0 && page.ids.session === sessionNumber).map((page) => [
      page.ids.scene,
      page.file.link,
      this.functions.formatTime(page.time.start),
      this.functions.calculateDuration(page.time.start, page.time.end)
    ]));
    this.spacer();
  }
  characterList() {
    this.dv.span("## Characters");
    this.dv.table(["", "Name", "Age", "Bio"], this.dv.pages("#character").sort((page) => page.file.name).where((page) => page.file.folder !== "Templates").map((page) => [
      this.functions.getImage(page),
      page.file.link,
      this.functions.calculateAge(page, this.dv.pages(`#campaign and -"Templates"`)[0]) ? this.functions.calculateAge(page, this.dv.pages(`#campaign and -"Templates"`)[0]) : "",
      page.bio
    ]));
    this.spacer();
  }
  synopsis(title = null) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    if ((_b = (_a = this.currentPage) == null ? void 0 : _a.dates) == null ? void 0 : _b.death) {
      this.dv.span("_Deceased " + this.functions.formatDate((_c = this.currentPage) == null ? void 0 : _c.dates.death) + "_<br/>");
    }
    if (title) {
      this.dv.span("## " + title);
    }
    if (((_d = this.currentPage) == null ? void 0 : _d.synopsis) !== null && ((_e = this.currentPage) == null ? void 0 : _e.synopsis) !== void 0 && ((_f = this.currentPage) == null ? void 0 : _f.synopsis) !== "") {
      if (((_g = this.currentPage) == null ? void 0 : _g.tags.indexOf("character/npc")) !== -1) {
        this.dv.span(((_h = this.currentPage) == null ? void 0 : _h.file.link) + (((_i = this.currentPage) == null ? void 0 : _i.dates.death) ? " was " : " is ") + ((_j = this.currentPage) == null ? void 0 : _j.synopsis));
      } else {
        this.dv.span((_k = this.currentPage) == null ? void 0 : _k.synopsis);
      }
    } else {
      this.dv.span("==Synopsis missing==");
    }
    this.spacer();
  }
  image(width = 75, height = 75) {
    const image = this.functions.getImage(this.currentPage, width, height);
    if (image !== "") {
      this.dv.span(image);
    }
    this.spacer();
  }
  nonPlayerCharacterInfo() {
    var _a, _b, _c, _d, _e;
    const age = this.functions.calculateAge(this.currentPage, this.dv.pages(`#campaign and -"Templates"`)[0]);
    this.dv.table(["**" + ((_a = this.currentPage) == null ? void 0 : _a.file.name) + "**", ""], [
      ["Status", ((_b = this.currentPage) == null ? void 0 : _b.dates.death) ? "Dead" : "Alive"],
      [((_c = this.currentPage) == null ? void 0 : _c.dates.death) ? "Age at Death" : "Age", age !== "" ? age : "==Dob or campaign date missing=="],
      ["Goals", ((_d = this.currentPage) == null ? void 0 : _d.goals) ? (_e = this.currentPage) == null ? void 0 : _e.goals : "==Goals missing=="]
    ]);
    this.spacer();
  }
  affiliations() {
    const affiliations = this.dv.pages("#faction").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.factions) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.factions[page.file.name]) !== void 0;
    });
    if (affiliations.length !== 0) {
      this.dv.span("## Affiliations");
      this.dv.table(["Faction", "Role"], affiliations.map((page) => {
        var _a;
        return [
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.factions[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  relationships() {
    const relationships = this.dv.pages("#character").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.characters) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.characters[page.file.name]) !== void 0;
    });
    if (relationships.length !== 0) {
      this.dv.span("## Relationships");
      this.dv.table(["", "Character", "Relationship"], this.dv.pages("#character").where((page) => {
        var _a, _b;
        return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.characters) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.characters[page.file.name]) !== void 0;
      }).map((page) => {
        var _a;
        return [
          this.functions.getImage(page),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.characters[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  characterEvents() {
    const events = this.dv.pages("#event").where((page) => {
      var _a, _b, _c;
      return page.file.folder !== "Templates" && ((_a = page.relationships) == null ? void 0 : _a.characters) && ((_c = page.relationships) == null ? void 0 : _c.characters[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0;
    });
    if (events.length !== 0) {
      this.dv.span("## Events involved in");
      this.dv.table(["Event", "Synopsis", "Date", "Additional Information"], events.map((page) => {
        var _a, _b;
        return [
          page.file.link,
          page.synopsis,
          this.functions.formatDate(page.dates.event, "short"),
          (_b = page.relationships) == null ? void 0 : _b.characters[(_a = this.currentPage) == null ? void 0 : _a.file.name]
        ];
      }));
      this.spacer();
    }
  }
  cluesKnowledge() {
    var _a;
    const unknownClues = this.dv.pages("#clue").where((page) => {
      var _a2, _b, _c;
      return page.file.folder !== "Templates" && ((_a2 = page.relationships) == null ? void 0 : _a2.characters) && ((_c = page.relationships) == null ? void 0 : _c.characters[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0 && page.dates.found === null;
    });
    const knownClues = this.dv.pages("#clue").where((page) => {
      var _a2, _b, _c;
      return page.file.folder !== "Templates" && ((_a2 = page.relationships) == null ? void 0 : _a2.characters) && ((_c = page.relationships) == null ? void 0 : _c.characters[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0 && page.dates.found !== null;
    });
    if (unknownClues.length !== 0 || knownClues.length !== 0) {
      this.dv.span("## Clues Known by " + ((_a = this.currentPage) == null ? void 0 : _a.file.name));
      if (unknownClues.length !== 0) {
        this.dv.table(["Unknown Clue", "Synopsis"], unknownClues.map((page) => [
          page.file.link,
          page.synopsis
        ]));
      }
      if (knownClues.length !== 0) {
        this.dv.table(["Known Clue", "Synopsis", "Discovered on"], knownClues.map((page) => [
          page.file.link,
          page.synopsis,
          this.functions.formatDate(page.dates.found, "short")
        ]));
      }
      this.spacer();
    }
  }
  knowledgeOfClue() {
    const npcs = this.dv.pages("#character").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.characters) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.characters[page.file.name]) !== void 0;
    });
    if (npcs.length !== 0) {
      this.dv.span("## Characters in the know");
      this.dv.table(["", "Character", "Additional Information"], npcs.map((page) => {
        var _a;
        return [
          this.functions.getImage(page),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.characters[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  characterLocations() {
    if (this.currentPage === void 0 || this.currentPage.relationships === void 0)
      return;
    const locations = this.dv.pages("#location").where((page) => {
      var _a, _b, _c;
      return page.file.folder !== "Templates" && this.currentPage !== void 0 && ((_a = this.currentPage) == null ? void 0 : _a.relationships) !== void 0 && ((_b = this.currentPage.relationships) == null ? void 0 : _b.locations) && ((_c = this.currentPage.relationships) == null ? void 0 : _c.locations[page.file.name]) !== void 0;
    });
    if (locations.length !== 0) {
      this.dv.span("## Notable Locations");
      this.dv.table(["", "Location", "Role"], locations.map((page) => {
        var _a, _b;
        return [
          this.functions.getImage(page, 70),
          page.file.link,
          (_b = (_a = this.currentPage) == null ? void 0 : _a.relationships) == null ? void 0 : _b.locations[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  locationEvents() {
    var _a;
    const events = this.dv.pages("#event").where((page) => {
      var _a2, _b, _c;
      return page.file.folder !== "Templates" && ((_a2 = page.relationships) == null ? void 0 : _a2.locations) && ((_c = page.relationships) == null ? void 0 : _c.locations[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0;
    }).sort((page) => page.file.name);
    if (events.length !== 0) {
      this.dv.span("## Events at " + ((_a = this.currentPage) == null ? void 0 : _a.file.name));
      this.dv.table(["Event", "Date", "Synopsis", "Additional Information"], events.map((page) => {
        var _a2, _b;
        return [
          page.file.link,
          this.functions.formatDate(page.dates.event, "short"),
          page.synopsis,
          (_b = page.relationships) == null ? void 0 : _b.locations[(_a2 = this.currentPage) == null ? void 0 : _a2.file.name]
        ];
      }));
      this.spacer();
    }
  }
  locationClues() {
    var _a;
    const clues = this.dv.pages("#clue").where((page) => {
      var _a2, _b, _c;
      return page.file.folder !== "Templates" && ((_a2 = page.relationships) == null ? void 0 : _a2.locations) && ((_c = page.relationships) == null ? void 0 : _c.locations[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0;
    }).sort((page) => page.file.name);
    if (clues.length !== 0) {
      this.dv.span("## Clues at " + ((_a = this.currentPage) == null ? void 0 : _a.file.name));
      this.dv.table(["Clue", "Found", "Synopsis", "Additional Information"], clues.map((page) => {
        var _a2, _b;
        return [
          page.file.link,
          page.dates.found === null ? "==No==" : this.functions.formatDate(page.dates.found, "short"),
          page.synopsis,
          (_b = page.relationships) == null ? void 0 : _b.locations[(_a2 = this.currentPage) == null ? void 0 : _a2.file.name]
        ];
      }));
      this.spacer();
    }
  }
  locationCharacters() {
    var _a;
    const characters = this.dv.pages("#character").where((page) => {
      var _a2, _b, _c;
      return page.file.folder !== "Templates" && ((_a2 = page.relationships) == null ? void 0 : _a2.locations) && ((_c = page.relationships) == null ? void 0 : _c.locations[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0;
    });
    if (characters.length !== 0) {
      this.dv.span("## Characters at " + ((_a = this.currentPage) == null ? void 0 : _a.file.name));
      this.dv.table(["", "Character", "Role"], characters.map((page) => {
        var _a2, _b;
        return [
          this.functions.getImage(page),
          page.file.link + this.functions.getDeathStatus(page),
          (_b = page.relationships) == null ? void 0 : _b.locations[(_a2 = this.currentPage) == null ? void 0 : _a2.file.name]
        ];
      }));
      this.spacer();
    }
  }
  factionCharacters() {
    const characters = this.dv.pages("#character").sort((page) => page.file.name).where((page) => {
      var _a, _b, _c;
      return page.file.folder !== "Templates" && ((_a = page.relationships) == null ? void 0 : _a.factions) !== null && ((_c = page.relationships) == null ? void 0 : _c.factions[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0;
    });
    if (characters.length !== 0) {
      this.dv.span("## Members");
      this.dv.table(["", "Character", "Role"], characters.map((page) => {
        var _a, _b;
        return [
          this.functions.getImage(page),
          page.file.link + this.functions.getDeathStatus(page),
          (_b = page.relationships) == null ? void 0 : _b.factions[(_a = this.currentPage) == null ? void 0 : _a.file.name]
        ];
      }));
      this.spacer();
    }
  }
  factionLocations() {
    const locations = this.dv.pages("#location").sort((page) => page.file.name).where((page) => {
      var _a, _b, _c;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships) !== null && ((_b = this.currentPage) == null ? void 0 : _b.relationships.locations) !== null && ((_c = this.currentPage) == null ? void 0 : _c.relationships.locations[page.file.name]) !== void 0;
    });
    if (locations.length !== 0) {
      this.dv.span("## Relevant Locations");
      this.dv.table(["", "Location", "Additional Information"], locations.map((page) => {
        var _a;
        return [
          this.functions.getImage(page, 70),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.locations[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  clueStatus() {
    var _a, _b, _c;
    this.dv.span((((_a = this.currentPage) == null ? void 0 : _a.dates.found) === void 0 || ((_b = this.currentPage) == null ? void 0 : _b.dates.found) === null ? "==Clue **NOT** found by the player characters==" : "_clue found by the player characters on " + this.functions.formatDate((_c = this.currentPage) == null ? void 0 : _c.dates.found, "short") + "_") + "<br/>&nbsp;<br/>");
  }
  clueEvents() {
    const events = this.dv.pages("#event").where((page) => {
      var _a, _b, _c;
      return page.file.folder !== "Templates" && ((_a = page.relationships) == null ? void 0 : _a.clues) && ((_c = page.relationships) == null ? void 0 : _c.clues[(_b = this.currentPage) == null ? void 0 : _b.file.name]) !== void 0;
    });
    if (events.length !== 0) {
      this.dv.span("## Part of events");
      this.dv.table(["Event", "Date", "Syopsis", "Additional Information"], events.map((page) => {
        var _a, _b;
        return [
          page.file.link,
          this.functions.formatDate(page.dates.event, "short"),
          page.synopsis,
          (_b = page.relationships) == null ? void 0 : _b.clues[(_a = this.currentPage) == null ? void 0 : _a.file.name]
        ];
      }));
      this.spacer();
    }
  }
  clueLocations() {
    const locations = this.dv.pages("#location").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.locations) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.locations[page.file.name]) !== void 0;
    });
    if (locations.length !== 0) {
      this.dv.span("## In Locations");
      this.dv.table(["", "Location", "Additional Information"], locations.map((page) => {
        var _a;
        return [
          this.functions.getImage(page, 70),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.locations[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  eventCharacters() {
    const characters = this.dv.pages("#character").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.characters) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.characters[page.file.name]) !== void 0;
    });
    if (characters.length !== 0) {
      this.dv.span("## Characters");
      this.dv.table(["", "Character", "Additional Information"], characters.map((page) => {
        var _a;
        return [
          this.functions.getImage(page),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.characters[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  eventClues() {
    const clues = this.dv.pages("#clue").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.clues) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.clues[page.file.name]) !== void 0;
    });
    if (clues.length !== 0) {
      this.dv.span("## Clues");
      this.dv.table(["Clue", "Found", "Synopsis", "Additional Information"], clues.map((page) => {
        var _a;
        return [
          page.file.link,
          page.dates.found === null ? "==No==" : this.functions.formatDate(page.dates.found, "short"),
          page.synopsis,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.clues[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  eventLocations() {
    const locations = this.dv.pages("#location").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.locations) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.locations[page.file.name]) !== void 0;
    });
    if (locations.length !== 0) {
      this.dv.span("## Locations");
      this.dv.table(["", "Location", "Additional Information"], locations.map((page) => {
        var _a;
        return [
          this.functions.getImage(page, 70),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.locations[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  sceneLocations() {
    const locations = this.dv.pages("#location").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.locations) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.locations[page.file.name]) !== void 0;
    });
    if (locations.length !== 0) {
      this.dv.span("## Scene Locations");
      this.dv.table(["", "Location", "Additional Information"], locations.map((page) => {
        var _a;
        return [
          this.functions.getImage(page, 70),
          page.file.link,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.locations[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  sceneNavigator() {
    const session = this.dv.pages("#session").where((session2) => {
      var _a;
      return session2.file.folder !== "Templates" && session2.ids !== void 0 && session2.ids.session === ((_a = this.currentPage) == null ? void 0 : _a.ids.session);
    })[0];
    const adventure = this.dv.pages("#adventure").where((adventure2) => adventure2.file.folder !== "Templates" && adventure2.ids !== void 0 && adventure2.ids.adventure === session.ids.adventure)[0];
    const campaign = this.dv.pages(`#campaign and -"Templates"`)[0];
    const previousScene = this.dv.pages("#scene").where((scene) => {
      var _a, _b;
      return scene.file.folder !== "Templates" && scene.ids !== void 0 && scene.ids.session === ((_a = this.currentPage) == null ? void 0 : _a.ids.session) && scene.ids.scene === ((_b = this.currentPage) == null ? void 0 : _b.ids.scene) - 1;
    });
    const nextScene = this.dv.pages("#scene").where((scene) => {
      var _a, _b;
      return scene.file.folder !== "Templates" && scene.ids !== void 0 && scene.ids.session === ((_a = this.currentPage) == null ? void 0 : _a.ids.session) && scene.ids.scene === ((_b = this.currentPage) == null ? void 0 : _b.ids.scene) + 1;
    });
    const tableElements = [];
    tableElements.push(["Adventure", adventure ? adventure.file.link : ""]);
    tableElements.push(["Session", session ? session.file.link : ""]);
    tableElements.push(["Session Notes", session ? "[[Notes - " + session.file.name + "]]" : ""]);
    if (previousScene.length > 0) {
      tableElements.push(["<< Previous Scene", previousScene[0].file.link]);
    }
    if (nextScene.length > 0) {
      tableElements.push(["Next Scene >>", nextScene[0].file.link]);
    }
    const table = this.dv.markdownTable(["Campaign", "" + campaign.file.link], tableElements);
    this.dv.paragraph(table);
    this.spacer();
  }
  sceneCharacters() {
    var _a, _b;
    const pages = [];
    for (let pagesCount = 0; pagesCount < ((_a = this.currentPage) == null ? void 0 : _a.file.outlinks.length); pagesCount++) {
      pages.push(this.dv.page((_b = this.currentPage) == null ? void 0 : _b.file.outlinks[pagesCount].path));
    }
    const characters = this.dv.array(pages).where((page) => page.tags.indexOf("character/npc") !== -1 || page.tags.indexOf("character/pc") !== -1).sort((page) => page.file.name);
    if (characters.length > 0) {
      this.dv.span("## Characters");
      this.dv.table(["", "Character"], characters.map((page) => [
        this.functions.getImage(page),
        page.file.link
      ]));
      this.spacer();
    }
  }
  sceneClues() {
    const clues = this.dv.pages("#clue").where((page) => {
      var _a, _b;
      return page.file.folder !== "Templates" && ((_a = this.currentPage) == null ? void 0 : _a.relationships.clues) && ((_b = this.currentPage) == null ? void 0 : _b.relationships.clues[page.file.name]) !== void 0;
    });
    if (clues.length !== 0) {
      this.dv.span("## Clues");
      this.dv.table(["Clue", "Found", "Synopsis", "Additional Information"], clues.map((page) => {
        var _a;
        return [
          page.file.link,
          page.dates.found === null ? "==No==" : this.functions.formatDate(page.dates.found, "short"),
          page.synopsis,
          (_a = this.currentPage) == null ? void 0 : _a.relationships.clues[page.file.name]
        ];
      }));
      this.spacer();
    }
  }
  sessionNavigator() {
    var _a;
    const campaign = this.dv.pages(`#campaign and -"Templates"`)[0];
    const adventure = this.dv.pages("#adventure").where((adventure2) => {
      var _a2;
      return adventure2.file.folder !== "Templates" && adventure2.ids.adventure == ((_a2 = this.currentPage) == null ? void 0 : _a2.ids.adventure);
    })[0];
    const previousSession = this.dv.pages("#session").where((session) => {
      var _a2, _b;
      return session.file.folder !== "Templates" && session.ids.adventure === ((_a2 = this.currentPage) == null ? void 0 : _a2.ids.adventure) && session.ids.session === ((_b = this.currentPage) == null ? void 0 : _b.ids.session) - 1;
    });
    const nextSession = this.dv.pages("#session").where((session) => {
      var _a2, _b;
      return session.file.folder !== "Templates" && session.ids.adventure === ((_a2 = this.currentPage) == null ? void 0 : _a2.ids.adventure) && session.ids.session === ((_b = this.currentPage) == null ? void 0 : _b.ids.session) + 1;
    });
    const tableElements = [];
    tableElements.push(["Adventure", adventure ? adventure.file.link : ""]);
    tableElements.push(["Introduction", "[[#Introduction]]"]);
    tableElements.push(["ABT Plot", "[[#ABT Plot]]"]);
    tableElements.push(["Story Circle Plot", "[[#Story Circle Plot]]"]);
    tableElements.push(["Notes", "[[Notes - " + ((_a = this.currentPage) == null ? void 0 : _a.file.name) + "]]"]);
    if (previousSession.length > 0) {
      tableElements.push(["<< Previous Session", previousSession[0].file.link]);
    }
    if (nextSession.length > 0) {
      tableElements.push(["Next Session >>", nextSession[0].file.link]);
    }
    const table = this.dv.markdownTable(["Campaign", "" + campaign.file.link], tableElements);
    this.dv.paragraph(table);
    this.spacer();
  }
};

// src/abstracts/AbstractModel.ts
var AbstractModel = class extends import_obsidian2.MarkdownRenderChild {
  constructor(functions, app, container, source, component, sourcePath) {
    super(container);
    this.functions = functions;
    this.app = app;
    this.container = container;
    this.source = source;
    this.component = component;
    this.sourcePath = sourcePath;
    this.redrawContainer = () => {
      if (this.isActivePage()) {
        this.renderComponent();
      }
    };
  }
  renderComponent(wait = 500) {
    return __async(this, null, function* () {
      setTimeout(() => {
        var _a, _b;
        this.dv = this.app.plugins.plugins.dataview.localApi(this.sourcePath, this.component, this.container);
        this.renderer = new RpgComponentFactory(this.functions, this.dv);
        console.log((_a = this.dv.current()) == null ? void 0 : _a.file.frontmatter);
        if (RpgMetadataValidator.validate(this.source, (_b = this.dv.current()) == null ? void 0 : _b.file.frontmatter)) {
          this.container.innerHTML = "";
          this.render();
        }
      }, wait);
    });
  }
  onload() {
    this.renderComponent(0);
    this.registerEvent(this.app.workspace.on("rpgmanager:refresh-views", this.redrawContainer));
  }
  isActivePage() {
    var _a, _b, _c, _d;
    const views = this.app.workspace.getLayout().main.children;
    for (let viewCounter = 0; viewCounter < views.length; viewCounter++) {
      if (((_b = (_a = views[viewCounter].state) == null ? void 0 : _a.state) == null ? void 0 : _b.file) !== void 0 && ((_d = (_c = views[viewCounter].state) == null ? void 0 : _c.state) == null ? void 0 : _d.file) === this.sourcePath) {
        return true;
      }
    }
    return false;
  }
};

// src/models/RpgNpcModel.ts
var RpgNpcModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.synopsis();
      this.renderer.image(300, 300);
      this.renderer.nonPlayerCharacterInfo();
      this.renderer.affiliations();
      this.renderer.relationships();
      this.renderer.characterEvents();
      this.renderer.cluesKnowledge();
      this.renderer.characterLocations();
    });
  }
};

// src/models/RpgErrorModel.ts
var RpgErrorModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.container.innerText = "The selected function does not exist in Rpg Manager";
    });
  }
};

// src/models/RpgAdventureModel.ts
var RpgAdventureModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      var _a;
      this.renderer.sessionList((_a = this.dv.current()) == null ? void 0 : _a.ids.adventure);
    });
  }
};

// src/models/RpgCampaignModel.ts
var RpgCampaignModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.adventureList();
      this.renderer.sessionList();
      this.renderer.characterList();
    });
  }
};

// src/models/RpgClueModel.ts
var RpgClueModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.clueStatus();
      this.renderer.image(450);
      this.renderer.synopsis();
      this.renderer.knowledgeOfClue();
      this.renderer.clueEvents();
      this.renderer.clueLocations();
    });
  }
};

// src/models/RpgEventModel.ts
var RpgEventModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.synopsis();
      this.renderer.image(450);
      this.renderer.eventCharacters();
      this.renderer.eventClues();
      this.renderer.eventLocations();
    });
  }
};

// src/models/RpgFactionModel.ts
var RpgFactionModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.synopsis();
      this.renderer.image(200);
      this.renderer.factionCharacters();
      this.renderer.factionLocations();
    });
  }
};

// src/models/RpgLocationModel.ts
var RpgLocationModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      var _a, _b;
      this.renderer.synopsis(((_a = this.dv.current()) == null ? void 0 : _a.address) ? (_b = this.dv.current()) == null ? void 0 : _b.address : null);
      this.renderer.image(450);
      this.renderer.locationEvents();
      this.renderer.locationClues();
      this.renderer.locationCharacters();
    });
  }
};

// src/models/RpgNotesModel.ts
var RpgNotesModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
    });
  }
};

// src/models/RpgPcModel.ts
var RpgPcModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.image(300, 300);
      this.renderer.affiliations();
      this.renderer.relationships();
      this.renderer.characterLocations();
    });
  }
};

// src/models/RpgSceneModel.ts
var RpgSceneModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.sceneNavigator();
      this.renderer.sceneLocations();
      this.renderer.sceneCharacters();
      this.renderer.sceneClues();
    });
  }
};

// src/models/RpgSessionModel.ts
var RpgSessionModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      var _a;
      this.renderer.sceneList((_a = this.dv.current()) == null ? void 0 : _a.ids.session);
    });
  }
};

// src/models/RpgSessionNavigationModel.ts
var RpgSessionNavigationModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      this.renderer.sessionNavigator();
    });
  }
};

// src/views/TimelineView.ts
var TimelineView_exports = {};
__export(TimelineView_exports, {
  TimelineView: () => TimelineView
});

// src/abstracts/AbstractView.ts
var AbstractView = class {
  constructor(functions, app, dv) {
    this.functions = functions;
    this.app = app;
    this.dv = dv;
    this.container = dv.container;
  }
};

// src/views/TimelineView.ts
var import_obsidian3 = require("obsidian");
var TimelineView = class extends AbstractView {
  render(data) {
    return __async(this, null, function* () {
      let response = this.header(data.campaign, data.campaignImage);
      for (let eventCount = 0; eventCount < data.events.length; eventCount++) {
        let fileLink = document.createElement("h3");
        yield import_obsidian3.MarkdownRenderer.renderMarkdown(data.events[eventCount].link, fileLink, this.dv.currentFilePath, null);
        let synopsis = document.createElement("span");
        yield import_obsidian3.MarkdownRenderer.renderMarkdown(data.events[eventCount].description, synopsis, this.dv.currentFilePath, null);
        const date = this.functions.formatDate(data.events[eventCount].time, "short");
        const time = this.functions.formatTime(data.events[eventCount].time);
        response += '<li><div class="bullet' + data.events[eventCount].getEventColour() + '"></div><div class="time">' + date + (time !== "00:00" ? "<br/>" + time : "") + '</div><div class="event-type' + data.events[eventCount].getEventColour() + '">' + data.events[eventCount].type + '</div><div class="desc">' + fileLink.outerHTML + synopsis.outerHTML + "</div></li>";
      }
      response += this.footer();
      this.dv.container.innerHTML = response;
    });
  }
  header(campaign, campaignImage) {
    return '<div class="rpgm-container"><div class="rpgm-header"' + campaignImage + '><div class="rpgm-color-overlay"><div class="rpgm-day-number">Timeline</div><div class="rpgm-date-right"><div class="rpgm-day-name">' + (campaign !== null ? campaign.file.name : "Campaign") + '</div><div class="rpgm-month">' + (campaign !== null ? this.functions.formatDate(campaign.dates.current, "long") : "") + '</div></div></div></div><div class="rpgm-timeline"><ul>';
  }
  footer() {
    return "</ul></div></div>";
  }
};

// src/factories/RpgViewFactory.ts
var RpgViewFactory = class {
  static initialise(functions, app) {
    this.functions = functions;
    this.app = app;
  }
  static create(viewName, dv) {
    return new TimelineView_exports[viewName + "View"](this.functions, this.app, dv);
  }
};

// src/models/RpgTimelineModel.ts
var TimelineEvent = class {
  constructor(time, link, description, type) {
    this.time = time;
    this.link = link;
    this.description = description;
    this.type = type;
  }
  getEventColour() {
    switch (this.type) {
      case "event":
        return "";
        break;
      case "birth":
        return " green";
        break;
      case "death":
        return " red";
        break;
      case "session":
        return " blue";
        break;
    }
  }
};
var RpgTimelineModel = class extends AbstractModel {
  render() {
    return __async(this, null, function* () {
      let timelineEvents = [];
      const events = this.dv.pages("#event").where((event) => {
        var _a, _b;
        return ((_a = event == null ? void 0 : event.dates) == null ? void 0 : _a.event) !== void 0 && ((_b = event == null ? void 0 : event.dates) == null ? void 0 : _b.event) !== null;
      });
      if (events !== void 0 && events.length > 0) {
        for (let eventCount = 0; eventCount < events.length; eventCount++) {
          timelineEvents.push(new TimelineEvent(events[eventCount].dates.event, events[eventCount].file.link.markdown(this.dv.currentFilePath), events[eventCount].synopsis ? events[eventCount].synopsis : "", "event"));
        }
      }
      let characters = this.dv.pages("#character").where((character) => {
        var _a, _b;
        return ((_a = character == null ? void 0 : character.dates) == null ? void 0 : _a.dob) !== void 0 && ((_b = character == null ? void 0 : character.dates) == null ? void 0 : _b.dob) !== null;
      });
      if (characters !== void 0 && characters.length > 0) {
        for (let charactersCount = 0; charactersCount < characters.length; charactersCount++) {
          timelineEvents.push(new TimelineEvent(characters[charactersCount].dates.dob, characters[charactersCount].file.link.markdown(this.dv.currentFilePath), characters[charactersCount].synopsis ? characters[charactersCount].synopsis : "", "birth"));
        }
      }
      characters = this.dv.pages("#character").where((character) => {
        var _a, _b;
        return ((_a = character == null ? void 0 : character.dates) == null ? void 0 : _a.death) !== void 0 && ((_b = character == null ? void 0 : character.dates) == null ? void 0 : _b.death) !== null;
      });
      if (characters !== void 0 && characters.length > 0) {
        for (let charactersCount = 0; charactersCount < characters.length; charactersCount++) {
          timelineEvents.push(new TimelineEvent(characters[charactersCount].dates.death, characters[charactersCount].file.link.markdown(this.dv.currentFilePath), characters[charactersCount].synopsis ? characters[charactersCount].synopsis : "", "death"));
        }
      }
      const sessions = this.dv.pages("#session").where((session) => {
        var _a, _b;
        return ((_a = session == null ? void 0 : session.dates) == null ? void 0 : _a.session) !== void 0 && ((_b = session == null ? void 0 : session.dates) == null ? void 0 : _b.session) !== null;
      });
      if (sessions !== void 0 && sessions.length > 0) {
        for (let sessionsCount = 0; sessionsCount < sessions.length; sessionsCount++) {
          timelineEvents.push(new TimelineEvent(sessions[sessionsCount].dates.session, sessions[sessionsCount].file.link.markdown(this.dv.currentFilePath), sessions[sessionsCount].synopsis ? sessions[sessionsCount].synopsis : "", "session"));
        }
      }
      timelineEvents.sort((a, b) => {
        return a.time - b.time;
      });
      const campaigns = this.dv.pages("#campaign").where((campaign) => campaign.file.folder !== "Templates");
      let campaignImage = null;
      if (campaigns !== void 0 && campaigns.length > 0) {
        campaignImage = this.functions.getImageLink(campaigns[0]);
        if (campaignImage !== null) {
          campaignImage = ` style="background: url('` + campaignImage + `');"`;
        } else {
          campaignImage = "";
        }
      }
      const data = {
        events: timelineEvents,
        campaign: campaigns !== void 0 && campaigns.length > 0 ? campaigns[0] : null,
        campaignImage
      };
      const view = RpgViewFactory.create("Timeline", this.dv);
      view.render(data);
    });
  }
};

// src/factories/RpgModelFactory.ts
var RpgModelFactory = class {
  static create(functions, app, container, source, component, sourcePath) {
    switch (source.replace(/[\n\r]/g, "").toLowerCase()) {
      case "adventure":
        return new RpgAdventureModel(functions, app, container, source, component, sourcePath);
        break;
      case "campaign":
        return new RpgCampaignModel(functions, app, container, source, component, sourcePath);
        break;
      case "clue":
        return new RpgClueModel(functions, app, container, source, component, sourcePath);
        break;
      case "event":
        return new RpgEventModel(functions, app, container, source, component, sourcePath);
        break;
      case "faction":
        return new RpgFactionModel(functions, app, container, source, component, sourcePath);
        break;
      case "location":
        return new RpgLocationModel(functions, app, container, source, component, sourcePath);
        break;
      case "npc":
        return new RpgNpcModel(functions, app, container, source, component, sourcePath);
        break;
      case "notes":
        return new RpgNotesModel(functions, app, container, source, component, sourcePath);
        break;
      case "pc":
        return new RpgPcModel(functions, app, container, source, component, sourcePath);
        break;
      case "scene":
        return new RpgSceneModel(functions, app, container, source, component, sourcePath);
        break;
      case "session":
        return new RpgSessionModel(functions, app, container, source, component, sourcePath);
        break;
      case "sessionnavigator":
        return new RpgSessionNavigationModel(functions, app, container, source, component, sourcePath);
        break;
      case "timeline":
        return new RpgTimelineModel(functions, app, container, source, component, sourcePath);
        break;
      default:
        return new RpgErrorModel(functions, app, container, source, component, sourcePath);
        break;
    }
  }
};

// src/main.ts
var RpgManager = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.areFunctionsLoaded = false;
  }
  onload() {
    return __async(this, null, function* () {
      console.log("Loading RpgManager " + this.manifest.version);
      this.refreshViews = (0, import_obsidian4.debounce)(this.refreshViews, 2500, true);
      this.registerEvent(this.app.metadataCache.on("resolved", function() {
        this.refreshViews();
      }.bind(this)));
      this.registerEvent(this.app.vault.on("modify", function() {
        this.refreshViews();
      }.bind(this)));
      this.registerPriorityCodeblockPostProcessor("RpgManager", -100, (source, el, ctx) => __async(this, null, function* () {
        return this.createRpgView(source, el, ctx, ctx.sourcePath);
      }));
    });
  }
  refreshViews() {
    this.app.workspace.trigger("rpgmanager:refresh-views");
  }
  createRpgView(source, el, component, sourcePath) {
    return __async(this, null, function* () {
      if (!this.areFunctionsLoaded) {
        this.areFunctionsLoaded = true;
        this.functions = this.addChild(RpgFunctions.create(this.app));
        RpgViewFactory.initialise(this.functions, this.app);
      }
      this.app.plugins.plugins.dataview.api.index.touch();
      component.addChild(RpgModelFactory.create(this.functions, this.app, el, source, component, sourcePath));
    });
  }
  registerPriorityCodeblockPostProcessor(language, priority, processor) {
    const registered = this.registerMarkdownCodeBlockProcessor(language, processor);
    registered.sortOrder = priority;
  }
  registerPriorityMarkdownPostProcessor(priority, processor) {
    const registered = this.registerMarkdownPostProcessor(processor);
    registered.sortOrder = priority;
  }
};
